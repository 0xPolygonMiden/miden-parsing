use miden_diagnostics::{SourceSpan, Span, Spanned};

use crate::symbols::Symbol;

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Spanned)]
pub struct Ident(Span<Symbol>);
impl Ident {
    pub fn new(span: SourceSpan, name: Symbol) -> Self {
        Self(Span::new(span, name))
    }

    pub fn from_str<S: Into<String>>(span: SourceSpan, name: S) -> Self {
        Self(Span::new(span, Symbol::intern(name)))
    }

    pub fn name(&self) -> Symbol {
        self.0.item
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct FunctionName {
    /// The module this function was defined in, if applicable
    pub module: Option<Ident>,
    pub name: Ident,
}
impl FunctionName {
    pub fn new(module: Ident, name: Ident) -> Self {
        Self {
            module: Some(module),
            name,
        }
    }
}
impl From<Ident> for FunctionName {
    fn from(name: Ident) -> Self {
        Self { module: None, name }
    }
}
impl From<Remote> for FunctionName {
    fn from(expr: Remote) -> Self {
        Self {
            module: Some(expr.module),
            name: expr.name,
        }
    }
}

#[derive(Debug, Clone, Spanned)]
pub struct Script {
    #[span]
    pub span: SourceSpan,
    pub forms: Vec<Form>,
}
impl Eq for Script {}
impl PartialEq for Script {
    fn eq(&self, other: &Self) -> bool {
        self.forms == other.forms
    }
}

#[derive(Debug, Clone, Spanned, PartialEq, Eq)]
pub enum Form {
    /// A module declaration
    Module(Module),
    /// A top-level expression
    Expr(Expr),
}

#[derive(Debug, Clone, Spanned)]
pub struct Module {
    #[span]
    pub span: SourceSpan,
    pub name: Ident,
    pub functions: Vec<Function>,
}
impl Module {
    pub fn new(span: SourceSpan, name: Ident, functions: Vec<Function>) -> Self {
        Self {
            span,
            name,
            functions,
        }
    }
}
impl Eq for Module {}
impl PartialEq for Module {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name && self.functions == other.functions
    }
}

#[derive(Debug, Clone, Spanned)]
pub struct Function {
    #[span]
    pub span: SourceSpan,
    pub name: FunctionName,
    pub params: Vec<Ident>,
    pub body: Box<Expr>,
}
impl Eq for Function {}
impl PartialEq for Function {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name && self.params == other.params && self.body == other.body
    }
}

#[derive(Debug, Clone, Spanned, PartialEq, Eq)]
pub enum Expr {
    /// Lambda abstraction, e.g. (lambda (x) (* x x))
    Lambda(Lambda),
    /// Let-bound variables, e.g. (let [x 1 y 2] (* x y))
    Let(Let),
    /// Function application, e.g. (square 1 2)
    Apply(Apply),
    /// Primitive operator, e.g. (* 2 2)
    Op(Op),
    /// List constructor, e.g. (hd . tl)
    Cons(Cons),
    /// Closure constructor, generated by the compiler at lambda definition sites
    Closure(Closure),
    /// Literal
    Lit(Lit),
    /// External, or fully-qualfied, function name, e.g. (std:println "hi")
    Remote(Remote),
    /// Symbols are atoms, i.e. literal identifiers whose value is themselves, e.g. `'nil`
    Symbol(Ident),
    /// Variable reference
    Var(Ident),
}

#[derive(Debug, Clone, Spanned)]
pub struct Remote {
    #[span]
    pub span: SourceSpan,
    pub module: Ident,
    pub name: Ident,
}
impl Eq for Remote {}
impl PartialEq for Remote {
    fn eq(&self, other: &Self) -> bool {
        self.module == other.module && self.name == other.name
    }
}

#[derive(Debug, Clone, Spanned, PartialEq, Eq)]
pub enum Lit {
    Int(#[span] Span<i64>),
}

#[derive(Debug, Clone, Spanned)]
pub struct Closure {
    #[span]
    pub span: SourceSpan,
    pub callee: Ident,
    pub captures: Vec<Ident>,
}
impl Eq for Closure {}
impl PartialEq for Closure {
    fn eq(&self, other: &Self) -> bool {
        self.callee == other.callee && self.captures == other.captures
    }
}

#[derive(Debug, Clone, Spanned)]
pub struct Lambda {
    #[span]
    pub span: SourceSpan,
    pub params: Vec<Ident>,
    pub body: Box<Expr>,
}
impl Eq for Lambda {}
impl PartialEq for Lambda {
    fn eq(&self, other: &Self) -> bool {
        self.params == other.params && self.body == other.body
    }
}

#[derive(Debug, Clone, Spanned)]
pub struct Let {
    #[span]
    pub span: SourceSpan,
    pub bindings: Vec<Binding>,
    pub body: Box<Expr>,
}
impl Eq for Let {}
impl PartialEq for Let {
    fn eq(&self, other: &Self) -> bool {
        self.bindings == other.bindings && self.body == other.body
    }
}

#[derive(Debug, Clone, Spanned)]
pub struct Binding {
    #[span]
    pub span: SourceSpan,
    pub name: Ident,
    pub value: Expr,
}
impl Eq for Binding {}
impl PartialEq for Binding {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name && self.value == other.value
    }
}

#[derive(Debug, Clone, Spanned)]
pub struct Apply {
    #[span]
    pub span: SourceSpan,
    pub callee: Box<Expr>,
    pub args: Vec<Expr>,
}
impl Eq for Apply {}
impl PartialEq for Apply {
    fn eq(&self, other: &Self) -> bool {
        self.callee == other.callee && self.args == other.args
    }
}

#[derive(Debug, Clone, Spanned)]
pub struct Op {
    #[span]
    pub span: SourceSpan,
    pub op: Operator,
    pub args: Vec<Expr>,
}
impl Eq for Op {}
impl PartialEq for Op {
    fn eq(&self, other: &Self) -> bool {
        self.op == other.op && self.args == other.args
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Operator {
    Add,
    Sub,
    Mul,
    Div,
    Hd,
    Tl,
    If,
}

#[derive(Debug, Clone, Spanned)]
pub struct Cons {
    #[span]
    pub span: SourceSpan,
    pub hd: Box<Expr>,
    pub tl: Box<Expr>,
}
impl Eq for Cons {}
impl PartialEq for Cons {
    fn eq(&self, other: &Self) -> bool {
        self.hd == other.hd && self.tl == other.tl
    }
}
